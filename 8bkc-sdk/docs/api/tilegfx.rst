PocketSprite TileGFX tile renderer
----------------------------------

The PocketSprite SDK comes with a powerful tile rendered. This tile rendered is capable of rapidly 
rendering maps of 8x8 graphics tiles to the screen, including effects like transparency and fading.
The SDK has integration with the files generated by `Tiled <http://www.mapeditor.org/>`_, a powerful
and  open-source tilemap editor, allowing the tilemaps generated in that program to be embedded in and
rendered from PocketSprite applications.

Creating tiles and tilemaps
---------------------------

Essentially, tiles are small (in this case, 8x8 pixels) images or parts of bigger images. These tiles can be
placed next to each other on a bigger canvas, not unlike floor tiles can be placed on a floor in order to
fill the entire floor. The bigger canvas is called a 'tile map' and can be however big you want it to be;
for instance, an entire level in your platformer game.

The advantage of this approach is that the tile map uses a much smaller amount of memory when compared to having
the entire map as an image: because tiles can be re-used (for example, the blue of the sky can be the same tile
repeated over and over again) and shared between maps, a tile map can use a much smaller amount of memory than
the graphics it represents. Using tiles also has some other advantages: for instance, tiles can be animated, leading
to an easy way to add individual elements of animation to a tilemap.

Tilegfx, the PocketSprite tile renderer, is optimized to work with maps generated by `Tiled <http://www.mapeditor.org/>`_
and the SDK contains a conversion program to convert its native .tsx/.tmx files directly into .c/.h files which
can then be included in a PocketSprite process.

In order to create a tiled tile map that works with tilegfx:

- First, create a .png containing all the tiles in an 8x8 pixel grid in a program of your choosing. Be sure
  to save the png as true color (RGB), not indexed. You can use one color (#FF00FF is regularily used for this)
  to indicate a transparent pixel.
- Open tiled, create a new tileset (File -> New -> New tileset). Select the png created earlier. It's important to select a tile height and 
  width of 8px by 8px here. Also set the transparency color here, if any.
- If so desired, modify the tile set (add animations, ...)
- Create the tilemap (File -> New -> New map). Select Orthogonal for orientation, CSV for tile layer format,
  Right Down for rendering order and set the tile size to 8px x 8px. You can freely choose the map size here.
- Create your map. Make sure the layer you're working in has a sane name, as that will be part of the name of the
  resulting tilegfx_map_t struct containing the layer data.
- Save the map and tileset somewhere in your project

The conversion from Tiled format to C file can now be automated. In a component.mk file in your PocketSprite 
project, add a line similar to this::

   $(eval $(call ConvertTiles,level1.tmx,levelgfx))

This will convert a tilemap file called ``level1.tmx`` and its associated tileset to a file called ``levelgfx.c`` as soon
as you build the project. The levelgfx.c is automatically compiled and linked with the project. A file called
``levelgfx.h`` is also created; you can use this to refer to the tilemap data from other C source files.

Note: because of quirks of the build system, this method breaks the automatic detection of other C files. This
means you need to specify them manually. For instance, if the component also contains an ``app_main.c`` and a 
``enemy.c`` file, a minimal component.mk would look like this::

   $(eval $(call ConvertTiles,level1.tmx,levelgfx))
   COMPONENT_OBJS += app_main.o enemy.o

Rendering tile maps
-------------------

With tile maps defined, you can now render them using the API defined down below. The way tilegfx works is that
it only has one render target, namely the screen buffer. The screen buffer can either be the same height and width
of the OLED screen of the PocketSprite, or it can be twice as large and scaled down when sent to the OLED screen.
The second option uses more memory, but by using subpixel scaling it can actually make the displayed graphics
look like it has a higher resolution than the screen natively has.

It is possible to render multiple layers over eachother: if a tile map has transparency defined, the transparent 
regions will allow the earlier rendered graphics to shine through.

.. include:: /_build/inc/tilegfx.inc
